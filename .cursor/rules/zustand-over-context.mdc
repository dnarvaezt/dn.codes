---
alwaysApply: true
---

# Zustand como SoluciÃ³n de Estado Global

## Regla Principal

- Usar **Zustand** como soluciÃ³n principal para manejo de estado global en React
- React Context queda prohibido para gestiÃ³n de estado compartido entre componentes

## JustificaciÃ³n

- Zustand es mÃ¡s simple y tiene menos boilerplate que Context
- Mejor rendimiento: evita re-renders innecesarios
- No requiere providers anidados
- API mÃ¡s limpia y directa
- Mejor experiencia de desarrollo con TypeScript
- Menor curva de aprendizaje

## CuÃ¡ndo Usar Zustand

### âœ… Casos de Uso Obligatorios

- Estado global de la aplicaciÃ³n
- Estado compartido entre mÃºltiples componentes no relacionados
- Estado que necesita persistencia
- Estado que requiere acciones/mutadores centralizados
- Estado que mÃºltiples rutas o pÃ¡ginas necesitan acceder

## CuÃ¡ndo NO Usar Zustand

### âŒ Excepciones Permitidas

- Estado local de un componente (usar `useState`, `useReducer`)
- Props drilling de mÃ¡ximo 2 niveles (pasar props directamente)
- Estado de formularios (usar librerÃ­as especializadas como react-hook-form)

## Estructura de Store con Zustand

### UbicaciÃ³n

```text
src/store/
â”œâ”€â”€ index.ts
â”œâ”€â”€ user-store.ts
â”œâ”€â”€ theme-store.ts
â””â”€â”€ [feature]-store.ts
```

### Convenciones de Nomenclatura

- Archivos: `[nombre]-store.ts` (kebab-case)
- Stores: `use[Nombre]Store` (PascalCase con prefijo "use")
- Ejemplo: `useUserStore`, `useThemeStore`

### Estructura BÃ¡sica de un Store

```typescript
import { create } from 'zustand';

interface [Nombre]State {
  // Estado
  value: string;
  count: number;

  // Acciones
  setValue: (value: string) => void;
  increment: () => void;
  reset: () => void;
}

export const use[Nombre]Store = create<[Nombre]State>((set) => ({
  // Estado inicial
  value: '',
  count: 0,

  // Acciones
  setValue: (value) => set({ value }),
  increment: () => set((state) => ({ count: state.count + 1 })),
  reset: () => set({ value: '', count: 0 }),
}));
```

## Reglas de ImplementaciÃ³n

### 1. ğŸ“¦ SeparaciÃ³n por Dominio

- Un store por dominio o feature
- No crear un store monolÃ­tico con todo el estado
- Separar responsabilidades claramente

### 2. ğŸ¯ Acciones Centralizadas

- Toda mutaciÃ³n de estado debe hacerse a travÃ©s de acciones definidas en el store
- No permitir mutaciÃ³n directa del estado desde componentes
- Las acciones deben tener nombres descriptivos y en presente

### 3. ğŸ” Selectores EspecÃ­ficos

- Usar selectores para extraer solo el estado necesario
- Evitar suscribirse a todo el store si solo se necesita una propiedad

```typescript
// âŒ Mal: se suscribe a todo el store
const store = useUserStore();

// âœ… Bien: selector especÃ­fico
const userName = useUserStore((state) => state.name);
const setUserName = useUserStore((state) => state.setName);
```

### 4. ğŸ§ª Testeable

- Los stores deben ser fÃ¡ciles de testear
- Exportar el estado inicial si es necesario para tests
- Las acciones deben ser funciones puras cuando sea posible

### 5. ğŸ“ TypeScript Obligatorio

- Todos los stores deben estar tipados
- Usar interfaces para definir la forma del estado
- No usar `any` en ningÃºn store

## Middleware Permitido

### Persist (Persistencia)

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export const useUserStore = create(
  persist<UserState>(
    (set) => ({
      // ... store implementation
    }),
    {
      name: 'user-storage',
    }
  )
);
```

### Devtools (Desarrollo)

```typescript
import { devtools } from 'zustand/middleware';

export const useUserStore = create(
  devtools<UserState>(
    (set) => ({
      // ... store implementation
    }),
    { name: 'UserStore' }
  )
);
```

## MigraciÃ³n desde React Context

### Prohibiciones

- âŒ No crear nuevos Context para estado global
- âŒ No usar `useContext` para estado compartido
- âŒ No crear Providers personalizados para estado

### Plan de MigraciÃ³n

1. Identificar Contexts existentes que manejan estado
2. Crear store equivalente en Zustand
3. Migrar consumidores del Context al nuevo store
4. Eliminar Context y Provider una vez migrado
5. Actualizar tests

## ValidaciÃ³n de Cumplimiento

### Checklist Antes de Crear Estado Global

- [ ] Â¿Es realmente estado global o puede ser local?
- [ ] Â¿Ya existe un store que pueda manejar este estado?
- [ ] Â¿He definido las interfaces TypeScript?
- [ ] Â¿Las acciones son claras y especÃ­ficas?
- [ ] Â¿Estoy usando selectores en los componentes?

## Anti-Patrones Prohibidos

### âŒ No Hacer

- Crear Context para estado global
- Usar `useContext` + `useState` para compartir estado
- Providers anidados para estado
- Prop drilling excesivo cuando Zustand es la soluciÃ³n
- Stores gigantes con todo el estado de la app
- MutaciÃ³n directa del estado sin acciones

## Excepciones Documentadas

### React Context Solo Para

- ComposiciÃ³n de componentes (children, render props)
- Tema (si no se usa Zustand para tema)
- InternacionalizaciÃ³n (i18n) ya configurada
- LibrerÃ­as de terceros que requieren Context

## Mantra

"Estado global = Zustand. Context = composiciÃ³n. Local = useState. Sin excepciones sin justificaciÃ³n."
