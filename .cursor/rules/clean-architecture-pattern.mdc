---
alwaysApply: true
---

# Clean Architecture Pattern

## DefiniciÃ³n

Este proyecto implementa **Clean Architecture** con **Domain-Driven Design (DDD)** y organizaciÃ³n **modular por features**.

## Estructura de Capas Obligatoria

### 1. Application Layer (`src/application/`)

LÃ³gica de negocio pura, **completamente independiente de frameworks y UI**.

**REGLA CRÃTICA**: Esta capa NO debe importar:

- âŒ React, Next.js, Vue, Angular u otro framework de UI
- âŒ LibrerÃ­as de componentes UI
- âŒ Hooks de React (`useState`, `useEffect`, etc.)
- âŒ Context API de React
- âŒ Nada relacionado con presentaciÃ³n o infraestructura

**Solo puede depender de**:

- âœ… TypeScript/JavaScript puro
- âœ… LibrerÃ­as de utilidades puras (lodash, date-fns, etc.)
- âœ… Abstracciones propias del dominio

#### 1.1 Core (`application/core/`)

Abstracciones y utilidades base del sistema:

```text
application/core/
â”œâ”€â”€ entity/           # Entidad base genÃ©rica
â”œâ”€â”€ routes/           # Servicio de rutas
â””â”€â”€ utils/            # Utilidades transversales (event bus, uuid)
```

#### 1.2 Domain (`application/domain/`)

MÃ³dulos de dominio organizados por entidad:

```text
application/domain/[entity]/
â”œâ”€â”€ [entity].model.ts                    # Modelos e interfaces
â”œâ”€â”€ [entity].service.ts                  # LÃ³gica de negocio
â”œâ”€â”€ [entity].repository.interface.ts     # Contrato de persistencia
â”œâ”€â”€ [entity].repository.memory.ts        # ImplementaciÃ³n (memory/mock)
â”œâ”€â”€ [entity].provider.ts                 # Factory/Provider (sin React, patrÃ³n de diseÃ±o puro)
â”œâ”€â”€ [entity].mock.data.ts                # Datos de prueba
â”œâ”€â”€ [entity].exceptions.ts               # Excepciones especÃ­ficas
â””â”€â”€ index.ts                             # Barrel export
```

**IMPORTANTE sobre `[entity].provider.ts`**:

- âœ… Es un patrÃ³n Factory o Provider genÃ©rico (sin framework)
- âœ… Instancia y configura el servicio con sus dependencias
- âœ… Solo usa TypeScript/JavaScript puro
- âŒ NO es un React Context Provider
- âŒ NO importa React ni usa hooks

**Dominios existentes**: activity, appointment, article, category, client, employee, invoice, product, stock, transaction

---

### 2. Infrastructure Layer (`src/infrastructure/`)

Implementaciones concretas, adaptadores y UI.

#### 2.1 Components (`infrastructure/components/`)

Componentes UI reutilizables y transversales:

```text
infrastructure/components/
â”œâ”€â”€ empty-state/
â”œâ”€â”€ icons/
â”œâ”€â”€ layout/
â”œâ”€â”€ pagination/
â”œâ”€â”€ theme/
â””â”€â”€ [component]/
    â”œâ”€â”€ [component].tsx
    â”œâ”€â”€ [component].scss
    â””â”€â”€ index.ts
```

#### 2.2 Modules (`infrastructure/modules/`)

Features organizadas por dominio:

```text
infrastructure/modules/[entity]/
â”œâ”€â”€ [entity]-page/           # Lista/CRUD principal
â”‚   â”œâ”€â”€ [entity]-page.tsx
â”‚   â”œâ”€â”€ [entity]-page.hook.ts
â”‚   â”œâ”€â”€ [entity]-page.scss
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ [entity]-detail/         # Vista de detalle
â”œâ”€â”€ [entity]-form/           # Formulario create/edit
â”œâ”€â”€ [entity]-[subfeature]/   # Sub-features especÃ­ficas
â”œâ”€â”€ [entity].routes.tsx      # ConfiguraciÃ³n de rutas
â”œâ”€â”€ [entity].constants.ts    # Constantes del mÃ³dulo
â””â”€â”€ index.ts
```

**Estructura de cada feature page**:

- `.tsx` â†’ Componente React (presentaciÃ³n)
- `.hook.ts` â†’ Custom hook (lÃ³gica)
- `.scss` â†’ Estilos aislados
- `index.ts` â†’ Barrel export

#### 2.3 Otras Carpetas

```text
infrastructure/
â”œâ”€â”€ hooks/        # Custom hooks compartidos
â”œâ”€â”€ routes/       # ConfiguraciÃ³n de routing
â”œâ”€â”€ config/       # ConfiguraciÃ³n de entorno
â””â”€â”€ assets/       # Recursos estÃ¡ticos
```

---

## Patrones Aplicados

### 1. ğŸ›ï¸ Clean Architecture / Hexagonal Architecture

- Dominio completamente desacoplado de infraestructura
- Repository pattern con interfaces
- InversiÃ³n de dependencias (DIP)
- NÃºcleo agnÃ³stico de frameworks

### 2. ğŸ“¦ Vertical Slicing

- Cada dominio estÃ¡ completamente aislado
- OrganizaciÃ³n por feature, no por tipo tÃ©cnico
- Alta cohesiÃ³n, bajo acoplamiento

### 3. ğŸ—„ï¸ Repository Pattern

- **Interfaces** en `application/domain/[entity]/[entity].repository.interface.ts`
- **Implementaciones** en `application/domain/[entity]/[entity].repository.[type].ts`
- SeparaciÃ³n clara entre contrato e implementaciÃ³n
- Facilita testing y cambio de persistencia

### 4. ğŸ› ï¸ Service Layer

- `EntityService` base genÃ©rico en `application/core/entity/`
- Servicios especÃ­ficos por dominio heredan del base
- LÃ³gica de negocio centralizada
- ReutilizaciÃ³n mediante herencia

### 5. ğŸ”Œ Provider Pattern (Dos Niveles)

#### Nivel 1: Domain Provider (Application Layer)

- `application/domain/[entity]/[entity].provider.ts`
- Factory/Provider pattern genÃ©rico (sin React)
- Instancia servicios con dependencias inyectadas
- Solo TypeScript puro
- **NO importa nada de Infrastructure**

#### Nivel 2: Zustand Store (Infrastructure Layer)

- `infrastructure/store/[entity]-store.ts`
- Zustand store para gestiÃ³n de estado global
- Importa y usa el Provider/Service del dominio (Application)
- Conecta el dominio (Application) con la UI (Infrastructure)
- Usa Zustand en lugar de React Context API

### 6. ğŸª Custom Hooks Pattern

- LÃ³gica separada en `[feature].hook.ts`
- Componentes `.tsx` solo para presentaciÃ³n
- SeparaciÃ³n de responsabilidades UI/lÃ³gica

### 7. ğŸ“¤ Barrel Exports

- Todos los mÃ³dulos usan `index.ts` para exports centralizados
- Simplifica imports
- Oculta estructura interna

### 8. ğŸ—„ï¸ Zustand para Estado Global

- Zustand es la soluciÃ³n obligatoria para estado global en Infrastructure
- **Prohibido** usar React Context API para estado compartido
- Los stores de Zustand viven en `infrastructure/store/`
- Los stores importan y usan servicios/providers de Application
- PatrÃ³n: Store â†’ Provider â†’ Service â†’ Repository

**Ventajas de Zustand sobre Context**:

- Sin providers anidados
- Mejor rendimiento (evita re-renders innecesarios)
- API mÃ¡s limpia y directa
- Menos boilerplate
- TypeScript nativo

---

## Flujo de Dependencias

```text
UI Components (infrastructure/modules)
    â†“ usa
Zustand Stores (infrastructure/store)
    â†“ importa y usa
Providers/Services (application/domain/[entity])
    â†“ usa
Repositories (application/domain/[entity])
    â†“ usa
Models & Interfaces (application/domain/[entity])
    â†“ extiende
Core Abstractions (application/core)
```

**Reglas de oro**:

1. Las dependencias siempre apuntan hacia adentro
2. `infrastructure` puede depender de `application` âœ…
3. `application` **NUNCA** depende de `infrastructure` âŒ
4. Zustand stores (Infrastructure) importan de Application, no al revÃ©s

### Diagrama de Flujo Completo con Zustand

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         INFRASTRUCTURE LAYER                â”‚
â”‚                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Component   â”‚ â”€â”€â”€â”€â”€â”€â”€>â”‚ Zustand Storeâ”‚ â”‚
â”‚  â”‚   (.tsx)     â”‚ usa     â”‚ (use*Store)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                  â”‚          â”‚
â”‚                                  â”‚ importa  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         APPLICATION LAYER        â”‚          â”‚
â”‚                                  â”‚          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Repository  â”‚ <â”€â”€â”€â”€â”€â”€â”€â”‚   Provider   â”‚ â”‚
â”‚  â”‚  Interface   â”‚ inyecta â”‚   (Factory)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â”‚                        â”‚          â”‚
â”‚         â”‚ usa              crea  â”‚          â”‚
â”‚         â”‚                        â–¼          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Repository   â”‚         â”‚   Service    â”‚ â”‚
â”‚  â”‚ Memory/API   â”‚         â”‚   (Logic)    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FLUJO DE DATOS:
1. Component usa Zustand store (useClientStore)
2. Store importa Provider/Service de Application
3. Store delega lÃ³gica al Service
4. Service usa Repository (a travÃ©s de interface)
5. Repository maneja persistencia

âŒ NUNCA: Application importa de Infrastructure
âœ… SIEMPRE: Infrastructure importa de Application
```

---

## Convenciones de Nomenclatura

### Regla Universal: kebab-case Obligatorio

**TODOS** los nombres de archivos y carpetas deben usar exclusivamente `kebab-case` (minÃºsculas separadas por guiones).

### Archivos y Directorios

- **Formato**: `kebab-case` obligatorio para TODOS los archivos y carpetas
- **Sufijos descriptivos**: `.model.ts`, `.service.ts`, `.hook.ts`, `.provider.ts`, `.repository.interface.ts`
- **Consistencia**: Mismo patrÃ³n entre todos los dominios
- **Sin excepciones**: No se permite `PascalCase`, `camelCase`, ni `snake_case` en nombres de archivos o carpetas

### Ejemplos de Archivos

```text
âœ… CORRECTO:
- client.model.ts
- client.service.ts
- client-page.hook.ts
- client.repository.interface.ts
- user-profile-form.tsx
- product-list-item.scss

âŒ INCORRECTO:
- ClientModel.ts (PascalCase)
- client_service.ts (snake_case)
- clientPageHook.ts (camelCase)
- UserProfileForm.tsx (PascalCase)
- productListItem.scss (camelCase)
```

### Ejemplos de Carpetas

```text
âœ… CORRECTO:
- /user-context/
- /product-catalog/
- /shopping-cart/
- /payment-gateway/
- /order-history/

âŒ INCORRECTO:
- /UserContext/ (PascalCase)
- /productCatalog/ (camelCase)
- /shopping_cart/ (snake_case)
- /PaymentGateway/ (PascalCase)
```

---

## Reglas de CreaciÃ³n de Nuevos Dominios

### Checklist Obligatorio

Antes de crear un nuevo dominio, DEBES:

- [ ] Crear estructura completa en `application/domain/[entity]/`
- [ ] Definir modelo e interfaces (`[entity].model.ts`)
- [ ] Crear interfaz de repositorio (`[entity].repository.interface.ts`)
- [ ] Implementar repositorio (mÃ­nimo memory: `[entity].repository.memory.ts`)
- [ ] Crear servicio que extienda `EntityService` (`[entity].service.ts`)
- [ ] Implementar provider React (`[entity].provider.ts`)
- [ ] Agregar datos mock si aplica (`[entity].mock.data.ts`)
- [ ] Crear excepciones especÃ­ficas si aplica (`[entity].exceptions.ts`)
- [ ] Crear `index.ts` con barrel exports
- [ ] Crear mÃ³dulo en `infrastructure/modules/[entity]/`
- [ ] Implementar al menos `[entity]-page` con `.tsx`, `.hook.ts`, `.scss`
- [ ] Configurar rutas en `[entity].routes.tsx`
- [ ] Agregar constantes en `[entity].constants.ts`

### Estructura MÃ­nima Requerida

```text
application/domain/[entity]/
â”œâ”€â”€ [entity].model.ts
â”œâ”€â”€ [entity].service.ts
â”œâ”€â”€ [entity].repository.interface.ts
â”œâ”€â”€ [entity].repository.memory.ts
â”œâ”€â”€ [entity].provider.ts
â””â”€â”€ index.ts

infrastructure/modules/[entity]/
â”œâ”€â”€ [entity]-page/
â”‚   â”œâ”€â”€ [entity]-page.tsx
â”‚   â”œâ”€â”€ [entity]-page.hook.ts
â”‚   â”œâ”€â”€ [entity]-page.scss
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ [entity].routes.tsx
â””â”€â”€ index.ts
```

---

## Reglas de ModificaciÃ³n

### 1. ğŸš« No Romper SeparaciÃ³n de Capas

- **Prohibido**: Importar desde `infrastructure/` hacia `application/`
- **Prohibido**: LÃ³gica de negocio en componentes UI
- **Prohibido**: Acceso directo a repositorios desde hooks/componentes (usar servicios)

### 2. ğŸ“ Mantener Consistencia

- Todos los dominios deben seguir la misma estructura
- No crear variaciones sin justificaciÃ³n explÃ­cita
- Respetar sufijos y nomenclatura establecida

### 3. ğŸ”’ EncapsulaciÃ³n

- Exports solo a travÃ©s de `index.ts`
- No exponer implementaciones internas
- Usar interfaces para contratos pÃºblicos

### 4. ğŸ§ª Testabilidad

- Separar lÃ³gica de presentaciÃ³n
- Usar interfaces para facilitar mocks
- Mantener servicios puros cuando sea posible

---

## Principios SOLID Aplicados

### Single Responsibility Principle (SRP)

- Cada archivo tiene una Ãºnica responsabilidad
- Servicios manejan lÃ³gica de negocio
- Repositorios manejan persistencia
- Componentes manejan UI
- Hooks manejan state/effects

### Open/Closed Principle (OCP)

- `EntityService` base extensible
- Interfaces permiten mÃºltiples implementaciones
- Nuevos dominios no modifican cÃ³digo existente

### Liskov Substitution Principle (LSP)

- Implementaciones de repositorio son intercambiables
- Servicios hijos pueden reemplazar a `EntityService`

### Interface Segregation Principle (ISP)

- Interfaces especÃ­ficas por dominio
- No interfaces monolÃ­ticas

### Dependency Inversion Principle (DIP)

- Dependencias apuntan a abstracciones (interfaces)
- Servicios dependen de interfaces de repositorio
- UI depende de servicios, no de repositorios

---

## ValidaciÃ³n de Cumplimiento

### Antes de Crear CÃ³digo

- [ ] Â¿IdentifiquÃ© correctamente la capa (application vs infrastructure)?
- [ ] Â¿Estoy siguiendo el patrÃ³n de estructura del dominio?
- [ ] Â¿Mis dependencias apuntan hacia adentro?
- [ ] Â¿Estoy usando nomenclatura kebab-case para TODOS los archivos y carpetas?
- [ ] Â¿VerifiquÃ© que NO hay PascalCase, camelCase ni snake_case en nombres de archivos o carpetas?
- [ ] Â¿CreÃ© barrel exports donde corresponde?

### DespuÃ©s de Crear CÃ³digo

- [ ] Â¿El cÃ³digo estÃ¡ en la capa correcta?
- [ ] Â¿La estructura coincide con dominios existentes?
- [ ] Â¿No hay imports cruzados prohibidos?
- [ ] Â¿Los archivos tienen sufijos correctos?
- [ ] Â¿TODOS los archivos y carpetas usan kebab-case exclusivamente?
- [ ] Â¿Existe `index.ts` para exports?

---

## Errores Comunes y Malinterpretaciones Prohibidas

### ğŸš¨ Regla de Estructura Estricta

**La estructura mostrada es EXACTA y NO admite variaciones**. No se permiten:

#### âŒ Carpetas Intermedias No Solicitadas

```text
// âŒ PROHIBIDO: Agregar niveles adicionales
application/domain/[entity]/models/         â†’ NO, debe ser plano
application/domain/[entity]/services/       â†’ NO, debe ser plano
application/domain/[entity]/repositories/   â†’ NO, debe ser plano

// âœ… CORRECTO: Estructura plana
application/domain/[entity]/
â”œâ”€â”€ [entity].model.ts
â”œâ”€â”€ [entity].service.ts
â””â”€â”€ [entity].repository.interface.ts
```

#### âŒ Variaciones de Nombres de Archivos

```text
// âŒ PROHIBIDO: Variaciones en sufijos
- client.repository.ts              â†’ Falta .interface antes de .ts
- client-repository.interface.ts    â†’ NO usar guiÃ³n antes de repository
- client.repo.interface.ts          â†’ NO abreviar repository
- client.interface.repository.ts    â†’ Orden incorrecto

// âœ… CORRECTO: Sufijos exactos
- client.repository.interface.ts    â†’ ÃšNICO formato permitido
- client.repository.memory.ts       â†’ ÃšNICO formato para implementaciones
```

#### âŒ Archivos Fuera de Lugar

```text
// âŒ PROHIBIDO: Ubicaciones incorrectas
infrastructure/modules/[entity]/[entity].service.ts    â†’ Servicios van en application/
infrastructure/modules/[entity]/[entity].provider.ts   â†’ Providers van en application/
application/domain/[entity]/[entity]-page.tsx          â†’ Componentes van en infrastructure/
application/domain/[entity]/[entity].routes.tsx        â†’ Rutas van en infrastructure/

// âœ… CORRECTO: Ubicaciones apropiadas
application/domain/[entity]/[entity].service.ts
application/domain/[entity]/[entity].provider.ts
infrastructure/modules/[entity]/[entity]-page/[entity]-page.tsx
infrastructure/modules/[entity]/[entity].routes.tsx
```

#### âŒ Combinar Archivos que Deben Estar Separados

```text
// âŒ PROHIBIDO: Un solo archivo para mÃºltiples responsabilidades
- client-page.tsx con hook integrado â†’ SEPARAR en .tsx + .hook.ts
- client.service.ts con repositorio â†’ SEPARAR en .service.ts + .repository.interface.ts
- index.ts con lÃ³gica â†’ Solo debe reexportar

// âœ… CORRECTO: Archivos separados por responsabilidad
infrastructure/modules/client/client-page/
â”œâ”€â”€ client-page.tsx        â†’ Solo presentaciÃ³n
â”œâ”€â”€ client-page.hook.ts    â†’ Solo lÃ³gica
â”œâ”€â”€ client-page.scss       â†’ Solo estilos
â””â”€â”€ index.ts               â†’ Solo exports
```

#### âŒ Inconsistencias en Nombres de Features

```text
// âŒ PROHIBIDO: Nombres inconsistentes entre carpetas
infrastructure/modules/client/
â”œâ”€â”€ client-list/           â†’ Debe ser client-page
â”œâ”€â”€ clientForm/            â†’ Debe ser client-form (kebab-case)
â”œâ”€â”€ detail/                â†’ Debe ser client-detail (incluir entity)
â””â”€â”€ ClientRoutes.tsx       â†’ Debe ser client.routes.tsx

// âœ… CORRECTO: Nomenclatura consistente
infrastructure/modules/client/
â”œâ”€â”€ client-page/           â†’ [entity]-page
â”œâ”€â”€ client-form/           â†’ [entity]-form
â”œâ”€â”€ client-detail/         â†’ [entity]-detail
â””â”€â”€ client.routes.tsx      â†’ [entity].routes.tsx
```

#### âŒ Estructura Incompleta de Features

```text
// âŒ PROHIBIDO: Feature sin archivos obligatorios
infrastructure/modules/client/client-page/
â”œâ”€â”€ client-page.tsx        â†’ Falta .hook.ts
â””â”€â”€ index.ts               â†’ Falta .scss

// âŒ PROHIBIDO: Feature sin barrel export
infrastructure/modules/client/client-page/
â”œâ”€â”€ client-page.tsx
â”œâ”€â”€ client-page.hook.ts
â””â”€â”€ client-page.scss       â†’ Falta index.ts

// âœ… CORRECTO: Feature completa
infrastructure/modules/client/client-page/
â”œâ”€â”€ client-page.tsx
â”œâ”€â”€ client-page.hook.ts
â”œâ”€â”€ client-page.scss
â””â”€â”€ index.ts
```

#### âŒ Omitir Archivos Obligatorios del Dominio

```text
// âŒ PROHIBIDO: Dominio sin estructura mÃ­nima
application/domain/client/
â”œâ”€â”€ client.model.ts
â””â”€â”€ client.service.ts      â†’ Faltan repository interface, provider, index.ts

// âœ… CORRECTO: Estructura mÃ­nima completa
application/domain/client/
â”œâ”€â”€ client.model.ts
â”œâ”€â”€ client.service.ts
â”œâ”€â”€ client.repository.interface.ts
â”œâ”€â”€ client.repository.memory.ts
â”œâ”€â”€ client.provider.ts
â””â”€â”€ index.ts
```

#### âŒ Barrel Exports Incorrectos

```text
// âŒ PROHIBIDO: index.ts con lÃ³gica
export const helper = () => { /* ... */ };
export * from './client.model';

// âŒ PROHIBIDO: Exports selectivos
export { Client } from './client.model';
export { ClientService } from './client.service';

// âŒ PROHIBIDO: Default exports
export { default } from './client.service';

// âœ… CORRECTO: Solo reexportaciones con *
export * from './client.model';
export * from './client.service';
export * from './client.repository.interface';
export * from './client.provider';
```

#### âŒ Mezclar Estilos de OrganizaciÃ³n

```text
// âŒ PROHIBIDO: Algunos mÃ³dulos con estructura, otros sin ella
infrastructure/modules/
â”œâ”€â”€ client/
â”‚   â”œâ”€â”€ client-page/       â†’ Estructura correcta
â”‚   â””â”€â”€ client-form/       â†’ Estructura correcta
â””â”€â”€ product/
    â”œâ”€â”€ ProductList.tsx    â†’ Inconsistente: sin carpeta, PascalCase
    â””â”€â”€ form.tsx           â†’ Inconsistente: sin prefijo entity

// âœ… CORRECTO: Todos los mÃ³dulos con la misma estructura
infrastructure/modules/
â”œâ”€â”€ client/
â”‚   â”œâ”€â”€ client-page/
â”‚   â”œâ”€â”€ client-form/
â”‚   â””â”€â”€ client-detail/
â””â”€â”€ product/
    â”œâ”€â”€ product-page/
    â”œâ”€â”€ product-form/
    â””â”€â”€ product-detail/
```

---

## Anti-Patrones Prohibidos

### âŒ No Hacer

- Importar de `infrastructure/` en `application/` (violaciÃ³n crÃ­tica)
- LÃ³gica de negocio en componentes `.tsx`
- Acceso directo a repositorios desde UI
- Mezclar capas en un mismo archivo
- Crear estructuras inconsistentes entre dominios
- Omitir interfaces de repositorio
- Servicios sin extender de `EntityService`
- MÃ³dulos sin estructura completa (tsx + hook + scss)
- **Usar nombres de archivos o carpetas que NO sean kebab-case**
- Usar `PascalCase`, `camelCase` o `snake_case` en nombres de archivos o carpetas
- **Usar React Context API en lugar de Zustand en `infrastructure/store/`**
- **Importar React o frameworks en `application/`**

### âŒ Imports y Exports: Reglas Estrictas

#### âŒ Imports Prohibidos en Application Layer (CRÃTICO)

**La capa `application/` NUNCA debe importar**:

```typescript
// âŒ PROHIBIDO: Imports de React o frameworks
import React from 'react';
import { useState, useEffect, useContext } from 'react';
import { NextPage } from 'next';
import { useRouter } from 'next/router';

// âŒ PROHIBIDO: Imports de Infrastructure
import { Button } from '@/infrastructure/components/ui/button';
import { useTheme } from '@/infrastructure/store/theme-store';
import { ClientPage } from '@/infrastructure/modules/client';

// âŒ PROHIBIDO: Imports de librerÃ­as de UI
import { Card } from 'antd';
import { Button } from '@shadcn/ui';
```

**Solo puede importar**:

```typescript
// âœ… CORRECTO: TypeScript/JavaScript puro
import { v4 as uuidv4 } from 'uuid';
import { format } from 'date-fns';
import _ from 'lodash';

// âœ… CORRECTO: Otros dominios de Application
import { User } from '@/application/domain/user';
import { ProductService } from '@/application/domain/product';

// âœ… CORRECTO: Core abstractions
import { EntityService } from '@/application/core/entity';
```

**Regla de oro**: Si un archivo en `application/` necesita importar algo de `react` o `infrastructure/`, estÃ¡ en la capa incorrecta.

#### âŒ Imports Prohibidos (Generales)

```typescript
// âŒ PROHIBIDO: Application importando de Infrastructure (VIOLACIÃ“N CRÃTICA)
// Archivo: application/domain/client/client.service.ts
import { ClientPage } from '@/infrastructure/modules/client';
import { useClientStore } from '@/infrastructure/store/client-store';
import { Button } from '@/infrastructure/components/ui/button';

// âŒ PROHIBIDO: Imports directos saltÃ¡ndose el barrel export
import { Client } from '@/application/domain/client/client.model';
import { ClientService } from '@/application/domain/client/client.service';

// âŒ PROHIBIDO: Componentes importando repositorios directamente
// Archivo: infrastructure/modules/client/client-page/client-page.hook.ts
import { ClientRepository } from '@/application/domain/client/client.repository.memory';

// âŒ PROHIBIDO: Usar Context API en lugar de Zustand
// Archivo: infrastructure/store/client-store.ts
import { createContext, useContext } from 'react'; // âŒ Usar Zustand en su lugar
```

#### âœ… Imports Correctos

```typescript
// âœ… CORRECTO: Usar barrel exports
import { Client, ClientService, ClientProvider } from '@/application/domain/client';

// âœ… CORRECTO: Infrastructure puede importar de Application
// Archivo: infrastructure/store/client-store.ts
import { create } from 'zustand';
import { ClientService, ClientProvider } from '@/application/domain/client';

// âœ… CORRECTO: Componentes usan Zustand stores
// Archivo: infrastructure/modules/client/client-page/client-page.hook.ts
import { useClientStore } from '@/infrastructure/store/client-store';

// âœ… CORRECTO: Stores delegan lÃ³gica a servicios del dominio
export const useClientStore = create((set) => {
  const clientService = ClientProvider.getInstance();
  return {
    clients: [],
    loadClients: async () => {
      const data = await clientService.getAll(); // Delega al dominio
      set({ clients: data });
    }
  };
});
```

#### âŒ Exports Prohibidos en index.ts

```typescript
// âŒ PROHIBIDO: Default exports
export default ClientService;

// âŒ PROHIBIDO: Exports selectivos
export { Client } from './client.model';
export { ClientService } from './client.service';

// âŒ PROHIBIDO: LÃ³gica en index.ts
export const createClient = () => { /* ... */ };
export * from './client.model';

// âŒ PROHIBIDO: Re-exports con renombre
export { Client as ClientModel } from './client.model';
```

#### âœ… Exports Correctos en index.ts

```typescript
// âœ… CORRECTO: Solo wildcard exports
export * from './client.model';
export * from './client.service';
export * from './client.repository.interface';
export * from './client.repository.memory';
export * from './client.provider';
```

---

### âŒ Ejemplos Prohibidos

#### Nomenclatura Incorrecta

```text
// âŒ Archivos con nomenclatura incorrecta
- ClientService.ts          â†’ debe ser: client.service.ts
- userRepository.ts          â†’ debe ser: user.repository.interface.ts
- Product_Model.ts           â†’ debe ser: product.model.ts
- OrderHistoryPage.tsx       â†’ debe ser: order-history-page.tsx

// âŒ Carpetas con nomenclatura incorrecta
- /UserProfile/              â†’ debe ser: /user-profile/
- /shoppingCart/             â†’ debe ser: /shopping-cart/
- /payment_gateway/          â†’ debe ser: /payment-gateway/
- /ProductCatalog/           â†’ debe ser: /product-catalog/
```

#### Violaciones de Arquitectura

```typescript
// âŒ Componente con lÃ³gica de negocio
export const ClientPage = () => {
  const [clients, setClients] = useState([]);

  useEffect(() => {
    // LÃ³gica compleja aquÃ­ - PROHIBIDO
    const filtered = clients.filter(/* ... */);
    // ...
  }, [clients]);
};

// âŒ Import de infrastructure en application
// application/domain/client/client.service.ts
import { ClientPage } from '@/infrastructure/modules/client'; // âŒ

// âŒ Acceso directo a repositorio desde hook
export const useClientPage = () => {
  const repository = useClientRepository(); // âŒ usar servicio
};
```

---

## Decisiones de DiseÃ±o No Negociables

### ğŸ”’ Estas reglas NO admiten interpretaciÃ³n ni variaciones

#### 1. Estructura de Carpetas es EXACTA

- **NO** agregar subcarpetas dentro de `application/domain/[entity]/`
- **NO** crear carpetas como `/models/`, `/services/`, `/repositories/` dentro del dominio
- **NO** reorganizar archivos "para mejor organizaciÃ³n"
- Todos los archivos del dominio van en el nivel raÃ­z de la carpeta del entity

#### 2. Nombres de Archivos Son LITERALES

- **NO** existe "flexibilidad creativa" en nombres
- **NO** usar abreviaciones: `repo` en lugar de `repository`
- **NO** cambiar orden de sufijos: `.interface.repository` estÃ¡ mal, solo `.repository.interface`
- **NO** omitir partes del nombre: `client.repository.ts` sin `.interface` estÃ¡ incompleto

#### 3. SeparaciÃ³n de Archivos es OBLIGATORIA

- **NO** combinar hook + componente en un solo archivo
- **NO** combinar service + repository en un solo archivo
- **NO** incluir mÃºltiples features en un solo componente
- Cada responsabilidad = un archivo separado

#### 4. kebab-case es UNIVERSAL y SIN EXCEPCIONES

- **NO** existe "caso especial" para usar PascalCase
- **NO** "componentes React deben ser PascalCase" - el archivo es kebab-case, la export es PascalCase
- **NO** mezclar estilos en el mismo proyecto
- **NO** usar snake_case ni camelCase nunca

#### 5. UbicaciÃ³n de Archivos NO es Negociable

- **Services, Repositories, Providers**: SOLO en `application/domain/[entity]/`
- **Componentes, Hooks de Features, Rutas**: SOLO en `infrastructure/modules/[entity]/`
- **NO** "decidir por conveniencia" dÃ³nde poner un archivo
- **NO** crear carpetas shared/common dentro de infrastructure para servicios

#### 6. Feature Completa = .tsx + .hook.ts + .scss + index.ts

- **NO** omitir `.hook.ts` "porque es simple"
- **NO** omitir `.scss` "porque uso Tailwind"
- **NO** omitir `index.ts` "porque solo hay un export"
- La estructura es COMPLETA o no estÃ¡ completa

#### 7. Dominio Completo = 6 Archivos MÃ­nimo

```text
[entity].model.ts
[entity].service.ts
[entity].repository.interface.ts
[entity].repository.memory.ts
[entity].provider.ts
index.ts
```

- **NO** crear dominio sin estos 6 archivos
- **NO** "empezar con lo bÃ¡sico y agregar despuÃ©s"
- **NO** saltarse el repository o el provider

#### 8. Consistencia es Ley

- **NO** tener diferentes estructuras entre mÃ³dulos
- **NO** "este mÃ³dulo es especial" como justificaciÃ³n
- **NO** mezclar patrones antiguos y nuevos
- TODOS los mÃ³dulos siguen el MISMO patrÃ³n exacto

---

## Checklist de ValidaciÃ³n Estricta

### âœ… Antes de Considerar el CÃ³digo Completo

#### Para Dominios (`application/domain/[entity]/`)

- [ ] Carpeta con nombre en kebab-case: `/user-context/` no `/UserContext/`
- [ ] Estructura plana (sin subcarpetas)
- [ ] Existe `[entity].model.ts` con nombre exacto
- [ ] Existe `[entity].service.ts` con nombre exacto
- [ ] Existe `[entity].repository.interface.ts` con nombre exacto (incluye `.interface`)
- [ ] Existe `[entity].repository.memory.ts` con nombre exacto
- [ ] Existe `[entity].provider.ts` con nombre exacto
- [ ] Existe `index.ts` que solo reexporta con `export *`
- [ ] NO hay carpetas `/models/`, `/services/`, `/repositories/`
- [ ] NO hay archivos con PascalCase, camelCase o snake_case
- [ ] **NO hay imports de React** en ningÃºn archivo
- [ ] **NO hay imports de frameworks UI** (Next.js, antd, shadcn)
- [ ] **NO hay imports de `infrastructure/`** en ningÃºn archivo
- [ ] **`[entity].provider.ts` NO usa Context API de React**
- [ ] **`[entity].provider.ts` es un Factory/Provider genÃ©rico** (TypeScript puro)

#### Para Features (`infrastructure/modules/[entity]/[entity]-[feature]/`)

- [ ] Carpeta con nombre en kebab-case: `/user-profile/` no `/UserProfile/`
- [ ] Nombre incluye el entity: `/client-page/` no `/page/`
- [ ] Existe `[entity]-[feature].tsx` con nombre exacto
- [ ] Existe `[entity]-[feature].hook.ts` con nombre exacto (incluye `.hook`)
- [ ] Existe `[entity]-[feature].scss` con nombre exacto
- [ ] Existe `index.ts` que solo reexporta
- [ ] NO hay lÃ³gica en el `.tsx`, solo presentaciÃ³n
- [ ] NO hay llamadas a repositorios desde el `.hook.ts`
- [ ] El `.hook.ts` usa servicios, no repositorios directamente

#### Para MÃ³dulos Completos (`infrastructure/modules/[entity]/`)

- [ ] Carpeta raÃ­z del mÃ³dulo en kebab-case
- [ ] Existe al menos una feature completa (`[entity]-page/`)
- [ ] Existe `[entity].routes.tsx` en la raÃ­z del mÃ³dulo
- [ ] Existe `index.ts` en la raÃ­z del mÃ³dulo
- [ ] Todas las features siguen la misma estructura
- [ ] NO hay archivos `.tsx` sueltos sin carpeta
- [ ] NO hay features con nombres inconsistentes

### âŒ SeÃ±ales de Alerta Inmediata

Si encuentras CUALQUIERA de estos, la estructura estÃ¡ INCORRECTA:

- [ ] Un archivo con nombre en PascalCase
- [ ] Una carpeta con nombre en PascalCase o camelCase o snake_case
- [ ] Un archivo `.repository.ts` sin `.interface` o sin `.memory`
- [ ] Un hook integrado en un archivo `.tsx`
- [ ] Un service o repository en `infrastructure/`
- [ ] Un componente `.tsx` en `application/`
- [ ] Una feature sin `.hook.ts` o sin `.scss` o sin `index.ts`
- [ ] Un dominio sin los 6 archivos mÃ­nimos
- [ ] Un `index.ts` con lÃ³gica o exports selectivos
- [ ] Carpetas como `/models/`, `/services/`, `/components/` dentro de un dominio
- [ ] Diferentes estructuras entre mÃ³dulos del mismo proyecto
- [ ] **Imports de React en `application/`** (useState, useEffect, Context API, etc.)
- [ ] **Imports de frameworks UI en `application/`** (Next.js, antd, shadcn, etc.)
- [ ] **Imports de `infrastructure/` en `application/`** (violaciÃ³n crÃ­tica del flujo de dependencias)
- [ ] **React Context Provider en `application/domain/[entity]/[entity].provider.ts`**
- [ ] **Uso de React Context API en lugar de Zustand en `infrastructure/store/`**

---

## Mantra

"Capas claras, dependencias hacia adentro, dominios consistentes, lÃ³gica separada de UI. **Application NO importa React ni frameworks ni Infrastructure. Infrastructure conecta dominio con UI usando Zustand.** Clean Architecture no es opcional, es obligatoria."

---

## Proceso de Pensamiento para Evitar Errores

### ğŸ§  Antes de Crear CUALQUIER Archivo

**Pregunta 1: Â¿Es un archivo de dominio o infraestructura?**

```text
Â¿Contiene lÃ³gica de negocio pura?
  â†’ SÃ: va en application/domain/[entity]/
  â†’ NO: continÃºa a la siguiente pregunta

Â¿Es un componente UI, hook de feature, ruta o mÃ³dulo?
  â†’ SÃ: va en infrastructure/modules/[entity]/
  â†’ NO: verificar si es hook compartido, store, o utils
```

**Pregunta 2: Â¿QuÃ© tipo de archivo es?**

```text
Para Application:
  - Modelo/Interfaz â†’ [entity].model.ts
  - Servicio â†’ [entity].service.ts
  - Repositorio Interface â†’ [entity].repository.interface.ts
  - Repositorio ImplementaciÃ³n â†’ [entity].repository.[tipo].ts
  - Provider/Factory (sin React) â†’ [entity].provider.ts
  - Excepciones â†’ [entity].exceptions.ts
  - Mock Data â†’ [entity].mock.data.ts
  - Barrel Export â†’ index.ts

Para Infrastructure Modules:
  - Componente â†’ [entity]-[feature]/[entity]-[feature].tsx
  - Hook â†’ [entity]-[feature]/[entity]-[feature].hook.ts
  - Estilos â†’ [entity]-[feature]/[entity]-[feature].scss
  - Barrel Export â†’ [entity]-[feature]/index.ts
  - Rutas â†’ [entity].routes.tsx
  - Constantes â†’ [entity].constants.ts
```

**Pregunta 3: Â¿El nombre del archivo es correcto?**

```text
âœ… Checklist rÃ¡pido:
  - Â¿EstÃ¡ en kebab-case? (todo minÃºsculas con guiones)
  - Â¿Incluye el nombre del entity?
  - Â¿Tiene el sufijo correcto? (.model, .service, .hook, etc.)
  - Â¿El sufijo estÃ¡ en el orden correcto? (.repository.interface no .interface.repository)
  - Â¿No tiene abreviaciones? (repository, no repo)
```

**Pregunta 4: Â¿La estructura del contenido es correcta?**

```text
Para componentes (.tsx):
  - Â¿Solo contiene JSX y presentaciÃ³n?
  - Â¿NO tiene lÃ³gica de negocio?
  - Â¿NO tiene llamadas directas a repositorios?
  - Â¿Usa el hook correspondiente para la lÃ³gica?

Para hooks (.hook.ts):
  - Â¿Contiene toda la lÃ³gica del componente?
  - Â¿Usa servicios en lugar de repositorios?
  - Â¿NO contiene JSX?

Para servicios (.service.ts):
  - Â¿Extiende de EntityService si es genÃ©rico?
  - Â¿Usa repositorios a travÃ©s de interfaces?
  - Â¿NO importa nada de infrastructure?

Para repositorios (.repository.interface.ts):
  - Â¿Es una interfaz/contrato?
  - Â¿NO contiene implementaciÃ³n?
  - Â¿Define los mÃ©todos de persistencia?
```

**Pregunta 5: Â¿EstÃ¡ completo?**

```text
Para un dominio nuevo:
  - [ ] 6 archivos mÃ­nimos presentes
  - [ ] index.ts con exports correctos
  - [ ] Sin carpetas intermedias
  - [ ] Todos los nombres en kebab-case

Para una feature nueva:
  - [ ] 4 archivos presentes (.tsx, .hook.ts, .scss, index.ts)
  - [ ] Carpeta con nombre correcto ([entity]-[feature])
  - [ ] SeparaciÃ³n clara de responsabilidades
  - [ ] index.ts con exports correctos
```

### âš ï¸ SeÃ±ales de que EstÃ¡s por Cometer un Error

Si estÃ¡s pensando alguna de estas cosas, **DETENTE**:

- "Voy a crear una carpeta `/models/` dentro del dominio para organizar mejor"
  - âŒ NO. Estructura plana obligatoria.

- "Este archivo es simple, no necesita hook separado"
  - âŒ NO. SeparaciÃ³n obligatoria siempre.

- "Voy a llamar este archivo `ClientService.ts` porque es mÃ¡s claro"
  - âŒ NO. kebab-case obligatorio: `client.service.ts`

- "Voy a poner el provider en infrastructure porque ahÃ­ se usa"
  - âŒ NO. Providers van en application/domain/

- "Voy a crear `client.repository.ts` sin el `.interface`"
  - âŒ NO. Interfaces de repositorio deben tener `.repository.interface.ts`

- "Este index.ts necesita una funciÃ³n helper"
  - âŒ NO. index.ts solo reexporta.

- "Voy a usar `export { Client }` en vez de `export *`"
  - âŒ NO. Solo wildcard exports en index.ts

- "Este mÃ³dulo es especial, voy a usar otra estructura"
  - âŒ NO. Consistencia es obligatoria.

### âœ… Flujo Correcto de CreaciÃ³n

```text
1. Identificar tipo de cÃ³digo (dominio o infraestructura)
   â†“
2. Determinar ubicaciÃ³n exacta segÃºn tipo
   â†“
3. Verificar estructura de carpetas existente
   â†“
4. Nombrar archivo con kebab-case + sufijo correcto
   â†“
5. Crear contenido segÃºn responsabilidad Ãºnica
   â†“
6. Verificar separaciÃ³n de responsabilidades
   â†“
7. Crear index.ts con wildcard exports
   â†“
8. Validar contra checklist estricta
   â†“
9. Verificar consistencia con otros mÃ³dulos/dominios
   â†“
10. Confirmar que NO se violÃ³ ninguna regla
```

---

## IntegraciÃ³n con Otras Reglas

- **DRY**: `EntityService` base evita duplicaciÃ³n
- **SOLID**: Aplicado en toda la arquitectura
- **YAGNI**: Crear solo estructura necesaria por dominio
- **KISS**: Mantener simplicidad en cada capa
- **TDD**: Arquitectura facilita testing por separaciÃ³n de capas

---

## Ejemplos PrÃ¡cticos: Provider Pattern Correcto

### âœ… CORRECTO: Provider en Application Layer (Sin React)

```typescript
// application/domain/user/user.provider.ts
import { UserService } from './user.service';
import { UserRepositoryMemory } from './user.repository.memory';

/**
 * Factory/Provider genÃ©rico (sin React)
 * Solo instancia y configura dependencias
 */
export class UserProvider {
  private static instance: UserService | null = null;

  static getInstance(): UserService {
    if (!this.instance) {
      const repository = new UserRepositoryMemory();
      this.instance = new UserService(repository);
    }
    return this.instance;
  }

  static createNew(): UserService {
    const repository = new UserRepositoryMemory();
    return new UserService(repository);
  }
}

// O alternativamente, funciÃ³n factory simple:
export const createUserService = (): UserService => {
  const repository = new UserRepositoryMemory();
  return new UserService(repository);
};
```

**CaracterÃ­sticas**:

- âœ… Solo TypeScript puro
- âœ… No importa React
- âœ… PatrÃ³n Factory/Singleton
- âœ… InyecciÃ³n de dependencias

### âœ… CORRECTO: Zustand Store en Infrastructure Layer

```typescript
// infrastructure/store/user-store.ts
import { create } from 'zustand';
import { UserService } from '@/application/domain/user';
import { UserProvider } from '@/application/domain/user';
import type { User } from '@/application/domain/user';

interface UserState {
  // Estado
  currentUser: User | null;
  isLoading: boolean;

  // Acciones
  loadUser: (id: string) => Promise<void>;
  updateUser: (user: User) => Promise<void>;
  clearUser: () => void;
}

/**
 * Zustand Store (solo en Infrastructure)
 * Conecta el dominio con la UI
 */
export const useUserStore = create<UserState>((set) => {
  // Obtiene el servicio del dominio (Application)
  const userService = UserProvider.getInstance();

  return {
    // Estado inicial
    currentUser: null,
    isLoading: false,

    // Acciones que usan el servicio del dominio
    loadUser: async (id: string) => {
      set({ isLoading: true });
      try {
        const user = await userService.getById(id);
        set({ currentUser: user, isLoading: false });
      } catch (error) {
        set({ isLoading: false });
        throw error;
      }
    },

    updateUser: async (user: User) => {
      set({ isLoading: true });
      try {
        await userService.update(user);
        set({ currentUser: user, isLoading: false });
      } catch (error) {
        set({ isLoading: false });
        throw error;
      }
    },

    clearUser: () => set({ currentUser: null }),
  };
});
```

**CaracterÃ­sticas**:

- âœ… Usa Zustand (permitido en Infrastructure)
- âœ… Importa el Provider/Service del dominio (Application â†’ Infrastructure âœ“)
- âœ… No contiene lÃ³gica de negocio (delega al servicio)
- âœ… Solo conecta dominio con UI
- âœ… No usa React Context API

### âŒ INCORRECTO: Importar de Infrastructure en Application

```typescript
// âŒ application/domain/user/user.provider.ts
import React, { createContext } from 'react'; // âŒ NO importar React
import { useUserStore } from '@/infrastructure/store/user-store'; // âŒ NO importar de Infrastructure

// âŒ Esto estÃ¡ MAL - Context API en Application Layer
export const UserContext = createContext<UserService | null>(null);

// âŒ Esto estÃ¡ MAL - Usar store de Infrastructure en Application
export class UserProvider {
  static getInstance(): UserService {
    const store = useUserStore(); // âŒ NO usar hooks de Infrastructure
    return store.userService;
  }
}
```

**Por quÃ© estÃ¡ mal**:

- âŒ Importa React en Application Layer
- âŒ Importa de `infrastructure/` en `application/` (violaciÃ³n crÃ­tica)
- âŒ Mezcla lÃ³gica de dominio con UI
- âŒ Acopla el dominio al framework
- âŒ Usa hooks de React en lÃ³gica de dominio

**Regla de oro**: `application/` NUNCA importa de `infrastructure/`. Solo `infrastructure/` puede importar de `application/`.

---

## Resumen Ejecutivo: 10 Reglas de Oro

Para consulta rÃ¡pida antes de crear o modificar cÃ³digo:

### 1. ğŸ“ Estructura Exacta, Sin Variaciones

- Dominio: estructura plana, 6 archivos mÃ­nimos
- Feature: 4 archivos obligatorios (.tsx, .hook.ts, .scss, index.ts)
- NO agregar niveles de carpetas intermedias

### 2. ğŸ”¤ kebab-case Obligatorio Universal

- **TODOS** los archivos y carpetas en kebab-case
- Sin excepciones, sin casos especiales
- NO PascalCase, NO camelCase, NO snake_case

### 3. ğŸ“ UbicaciÃ³n No Negociable

- `application/domain/`: modelos, servicios, repositorios, providers
- `infrastructure/modules/`: componentes, hooks, rutas, estilos
- NUNCA al revÃ©s

### 4. ğŸ”— SeparaciÃ³n de Responsabilidades

- Un archivo = una responsabilidad
- NO combinar hook + componente
- NO combinar service + repository

### 5. ğŸ“ Sufijos Exactos y Literales

- `.repository.interface.ts` (NO `.repository.ts`)
- `.repository.memory.ts` (NO `.repository.ts`)
- `.hook.ts` (NO `.hooks.ts`)
- NO abreviar, NO cambiar orden

### 6. ğŸ”„ Barrel Exports Estrictos

- `index.ts` solo con `export *`
- Sin lÃ³gica, sin exports selectivos
- Sin default exports
- Sin re-exports con renombre

### 7. â†—ï¸ Flujo de Dependencias

- `infrastructure` â†’ `application` âœ…
- `application` â†’ `infrastructure` âŒ
- Components/Hooks â†’ Services âœ…
- Components/Hooks â†’ Repositories âŒ

### 8. ğŸ” Estructura MÃ­nima Completa

- Dominio: 6 archivos obligatorios
- Feature: 4 archivos obligatorios
- NO omitir archivos "porque es simple"
- TODO completo o nada

### 9. ğŸ¯ Consistencia Total

- TODOS los dominios igual estructura
- TODOS los mÃ³dulos igual estructura
- NO "este es especial"
- NO mezclar patrones

### 10. âš ï¸ Si Dudas, EstÃ¡ Mal

- NO existe "flexibilidad" en estructura
- NO existe "interpretaciÃ³n" en nomenclatura
- NO existe "caso especial" justificado
- Reglas son EXACTAS y LITERALES

---

## Ãšltima ValidaciÃ³n

Antes de considerar el cÃ³digo terminado, responde SÃ a TODO:

- [ ] Â¿Todos los archivos estÃ¡n en kebab-case?
- [ ] Â¿La estructura es EXACTA a los ejemplos?
- [ ] Â¿NO hay carpetas intermedias no solicitadas?
- [ ] Â¿Cada feature tiene sus 4 archivos?
- [ ] Â¿Cada dominio tiene sus 6 archivos?
- [ ] Â¿Los index.ts solo usan `export *`?
- [ ] Â¿NO hay imports de infrastructure en application?
- [ ] **Â¿NO hay imports de React en application/?**
- [ ] **Â¿NO hay imports de frameworks UI en application/?**
- [ ] **Â¿[entity].provider.ts en application/ es TypeScript puro (sin React)?**
- [ ] **Â¿Se estÃ¡ usando Zustand en lugar de React Context en infrastructure/store/?**
- [ ] **Â¿Los stores de Zustand importan de Application (no al revÃ©s)?**
- [ ] Â¿Los hooks usan servicios, no repositorios?
- [ ] Â¿Todos los mÃ³dulos tienen la misma estructura?
- [ ] Â¿NO violÃ© ninguna de las 10 reglas de oro?

**Si alguna respuesta es NO, el cÃ³digo NO estÃ¡ completo.**
